unit YQAPI;

interface

uses
    SysUtils, Classes, Windows, RegExpr;

const
    FIDX_LAST = 2147483647;
    cDeltaSize = 1.5;

type
    TBMJumpTable = array[0..255] of Integer;

    TFastPosProc = function(const aSource, aFind: Pointer; const aSourceLen, aFindLen: Integer; var JumpTable: TBMJumpTable): Pointer;

function HtmlToGbk(html: string): string;

function NCPos(sub, source: string): integer;

function FieldCount(const strRecord, strFs: string): integer;

function StrCount(Sub, S: string): Integer;

function FieldValue(strSplit: string; str: string; iField: integer; cs: Boolean = False): string;

function FastPosNoCase(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;

function GetFieldValueByName(RecordStr, FieldName: string; From: Integer = 1; Surround: string = '<>'): string;

procedure MakeBMTable(Buffer: PChar; BufferLen: Integer; var JumpTable: TBMJumpTable);

procedure MakeBMTableNoCase(Buffer: PChar; BufferLen: Integer; var JumpTable: TBMJumpTable);

function BMPos(const aSource, aFind: Pointer; const aSourceLen, aFindLen: Integer; var JumpTable: TBMJumpTable): Pointer;

function BMPosNoCase(const aSource, aFind: Pointer; const aSourceLen, aFindLen: Integer; var JumpTable: TBMJumpTable): Pointer;

function SmartPos(const SearchStr, SourceStr: string; const CaseSensitive: Boolean = TRUE; const StartPos: Integer = 1; const ForwardSearch: Boolean = TRUE): Integer;

function FastPos(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;

function FastPosBack(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;

function FastPosBackNoCase(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;

function FastReplace(const aSourceString: string; const aFindString, aReplaceString: string; CaseSensitive: Boolean = False): string;

procedure FastCharMove(const Source; var Dest; Count: Integer);


//正则提取函数
function GetMatch(strText: string; strExp: string; idx: integer = 0; bMS: Boolean = true; bMG: Boolean = false; bMR: Boolean = false): string;

function GetMatchsEx(strText: string; strExp: string; Matchs: TStrings = nil; bMS: Boolean = false; bMG: Boolean = false; bMR: Boolean = false; bmI: Boolean = False; iContent: integer = -1): Integer;

function GetMatchs_V3(strText: string; strExp: string; Matchs: TStrings = nil; bMS: Boolean = false; bMG: Boolean = false; bMR: Boolean = false; iContent: integer = 0): integer;

var
    GUpcaseTable: array[0..255] of char;
    GUpcaseLUT: Pointer;
    I: Integer;

implementation

procedure FastCharMove(const Source; var Dest; Count: Integer);
asm
//Note:  When this function is called, delphi passes the parameters as follows
//ECX = Count
//EAX = Const Source
//EDX = Var Dest

    //If no bytes to copy, just quit altogether, no point pushing registers
        cmp     ECX, 0
        Je      @JustQuit
    //Preserve the critical delphi registers
        push    ESI
        push    EDI
    //move Source into ESI  (generally the SOURCE register)
    //move Dest into EDI (generally the DEST register for string commands)
    //This may not actually be neccessary, as I am not using MOVsb etc
    //I may be able just to use EAX and EDX, there may be a penalty for
    //not using ESI, EDI but I doubt it, this is another thing worth trying !
        mov     ESI, EAX
        mov     EDI, EDX
    //The following loop is the same as repNZ MovSB, but oddly quicker !
@Loop:
    //Get the source byte
        Mov     AL, [ESI]
    //Point to next byte
        Inc     ESI
    //Put it into the Dest
        mov     [EDI], AL
    //Point dest to next position
        Inc     EDI
    //Dec ECX to note how many we have left to copy
        Dec     ECX
    //If ECX <> 0 then loop
        Jnz     @Loop
    //Another optimization note.
    //Many people like to do this
    //Mov AL, [ESI]
    //Mov [EDI], Al
    //Inc ESI
    //Inc ESI
    //There is a hidden problem here, I wont go into too much detail, but
    //the pentium can continue processing instructions while it is still
    //working out the result of INC ESI or INC EDI
    //(almost like a multithreaded CPU)
    //if, however, you go to use them while they are still being calculated
    //the processor will stop until they are calculated (a penalty)
    //Therefore I alter ESI and EDI as far in advance as possible of using them
    //Pop the critical Delphi registers that we have altered
        pop     EDI
        pop     ESI

@JustQuit:
end;

function FastReplace(const aSourceString: string; const aFindString, aReplaceString: string; CaseSensitive: Boolean = False): string;
var
    PResult: PChar;
    PReplace: PChar;
    PSource: PChar;
    PFind: PChar;
    PPosition: PChar;
    CurrentPos, BytesUsed, lResult, lReplace, lSource, lFind: Integer;
    Find: TFastPosProc;
    CopySize: Integer;
    JumpTable: TBMJumpTable;
begin
    LSource := Length(aSourceString);
    if LSource = 0 then
    begin
        Result := aSourceString;
        exit;
    end;
    PSource := @aSourceString[1];

    LFind := Length(aFindString);
    if LFind = 0 then
    begin
        result := aSourceString;
        exit;
    end;
    PFind := @aFindString[1];

    LReplace := Length(aReplaceString);

  //Here we may get an Integer Overflow, or OutOfMemory, if so, we use a Delta
    try
        if LReplace <= LFind then
            SetLength(Result, lSource)
        else
            SetLength(Result, (LSource * LReplace) div LFind);
    except
        SetLength(Result, 0);
    end;

    LResult := Length(Result);
    if LResult = 0 then
    begin
        LResult := Trunc((LSource + LReplace) * cDeltaSize);
        SetLength(Result, LResult);
    end;

    PResult := @Result[1];

    if CaseSensitive then
    begin
        MakeBMTable(PChar(AFindString), lFind, JumpTable);
        Find := BMPos;
    end
    else
    begin
        MakeBMTableNoCase(PChar(AFindString), lFind, JumpTable);
        Find := BMPosNoCase;
    end;

    BytesUsed := 0;
    if LReplace > 0 then
    begin
        PReplace := @aReplaceString[1];
        repeat
            PPosition := Find(PSource, PFind, lSource, lFind, JumpTable);
            if PPosition = nil then
                break;

            CopySize := PPosition - PSource;
            Inc(BytesUsed, CopySize + LReplace);

            if BytesUsed >= LResult then
            begin
    //We have run out of space
                CurrentPos := Integer(PResult) - Integer(@Result[1]) + 1;
                LResult := Trunc(LResult * cDeltaSize);
                SetLength(Result, LResult);
                PResult := @Result[CurrentPos];
            end;

            FastCharMove(PSource^, PResult^, CopySize);
            Dec(lSource, CopySize + LFind);
            Inc(PSource, CopySize + LFind);
            Inc(PResult, CopySize);

            FastCharMove(PReplace^, PResult^, LReplace);
            Inc(PResult, LReplace);

        until lSource < lFind;
    end
    else
    begin
        repeat
            PPosition := Find(PSource, PFind, lSource, lFind, JumpTable);
            if PPosition = nil then
                break;

            CopySize := PPosition - PSource;
            FastCharMove(PSource^, PResult^, CopySize);
            Dec(lSource, CopySize + LFind);
            Inc(PSource, CopySize + LFind);
            Inc(PResult, CopySize);
            Inc(BytesUsed, CopySize);
        until lSource < lFind;
    end;

    SetLength(Result, (PResult + LSource) - @Result[1]);
    if LSource > 0 then
        FastCharMove(PSource^, Result[BytesUsed + 1], LSource);
end;

function GetMatch(strText: string; strExp: string; idx: integer = 0;    //0表示
    bMS: Boolean = true; bMG: Boolean = false; bMR: Boolean = false): string;
var
    i, nums: integer;
    RegExpr: TRegExpr;
    strLine, strContent: string;
begin
    result := '';
    if strExp = '' then
        exit;

    RegExpr := TRegExpr.Create;
    RegExpr.ModifierS := bMS;
    RegExpr.ModifierG := bMG;
    RegExpr.ModifierR := bMR;
    RegExpr.ModifierI := true; //不区分大小写
    RegExpr.Expression := strExp;

    RegExpr.Expression := strExp;
    if RegExpr.Exec(strText) then
    begin
        if idx > RegExpr.SubExprMatchCount then
            idx := 0;
        result := RegExpr.Match[idx];
    end;

    RegExpr.Free;
end;

function GetMatchs(strText: string; strExp: string; Matchs: TStrings = nil; bMS: Boolean = true; bMG: Boolean = false; bMR: Boolean = false; Ver: byte = 1; iContent: integer = 0): integer;

    //2014-11-24 17:05 TIGER 如果使用widestring, 中英文计算会错误...暂时无解
    //function GetMatchContent(strText: widestring; iContent, iMatchPos: integer): string;
    function GetMatchContent(strText: string; iContent, iMatchPos: integer; var line: integer): string;
    var
        v: string;
        istart, iend: integer;
    begin
        istart := iMatchPos - (iContent div 2);
        if istart < 1 then
            istart := 1;

        //iend:= iMatchPos+(iContent div 2);
        //if iend>length(strText) then iend:=length(strText);

        result := copy(strText, istart, iContent);

        //2014-11-24 17:14 TIGER 输出所在行
        v := copy(strText, 1, istart);
        line := StrCount(#13#10, v);

        {
        result:= '';
        if iContent<length(strMatch) then exit;

        ipos:= pos(strMatch, strText);
        if ipos<1 then exit;
        istart:= ipos-(iContent div 2);
        if istart<1 then istart:=1;

        iend:= ipos+(iContent div 2);
        if iend>length(strText) then iend:=length(strText);

        result:= copy(strText, istart, iend-istart);
        }
    end;

var
    RegExpr: TRegExpr;
    i, nums, line: integer;
    sline, cont: string;
    DataStrs: TStrings;
begin
    result := 0;
    if strExp = '' then
        exit;

    RegExpr := TRegExpr.Create;
    DataStrs := TStringList.Create;
    try
        with RegExpr do
        begin
            ModifierS := bMS;
            ModifierG := bMG;
            ModifierR := bMR;
            ModifierI := true; //不区分大小写
            Expression := strExp;

            if Exec(strText) then
            begin
                repeat
                    sline := '';

                    if (Ver = 2) or (Ver = 3) then
                    begin
                        nums := 0;
                        if Ver = 2 then
                            nums := RegExpr.SubExprMatchCount;

                        cont := '';
                        line := -1;
                        for i := 0 to nums do
                        begin
                            if iContent > 0 then
                            begin
                                cont := GetMatchContent(strText, iContent, RegExpr.MatchPos[i], line);
                                cont := FastReplace(cont, #13#10, '', false);
                                cont := FastReplace(cont, #09, '', false);
                            end;

                            sline := sline + '<line>' + inttostr(line) + '</line>' + '<match>' + RegExpr.Match[i] + '</match>' + '<content>' + cont + '</content>' + #09
                        end;
                    end
                    else
                    begin
                        sline := RegExpr.Match[iContent];
                    end;
                    Inc(result);
                    DataStrs.Add(sline);
                until not ExecNext;
                if Assigned(Matchs) then
                    Matchs.Assign(DataStrs);
            end;
        end;
    finally
        RegExpr.Free;
        DataStrs.Free;
    end;
end;



//根据给以的条件表达式进行查找并输出结果, 以制表符隔开
//Matchs允许为nil
//返回匹配个数
//2008-12-08 修正或者改进一个错误, 为和以前的代码保持兼容, 增加版本号
//2008-12-16 增加iContent参数, 表示输出上下文
function GetMatchsEx(strText: string; strExp: string; Matchs: TStrings = nil; bMS: Boolean = false; bMG: Boolean = false; bMR: Boolean = false; bmI: Boolean = False; iContent: integer = -1): Integer;
var
    i, nums: integer;
    RegExpr: TRegExpr;
    strLine, strContent: string;
begin
    Result := 0;
    if strExp = '' then
        exit;

    RegExpr := TRegExpr.Create;
    try
        with RegExpr do
        begin
            ModifierS := bMS;
            ModifierG := bMG;
            ModifierR := bMR;
            ModifierI := bmI;
            Expression := strExp;

            if Exec(strText) then
            begin
                //生成列数据
                repeat
                    if (iContent <> -1) and Assigned(Matchs) then
                        Matchs.Add(Match[iContent])
                    else
                    begin
                        strLine := '';
                        for I := 0 to SubExprMatchCount do
                            strLine := strLine + Match[I] + #9;
                        if Assigned(Matchs) then
                            Matchs.Add(strLine);
                    end;
                    Inc(Result);
                until not ExecNext;
            end;
        end;
    finally
        RegExpr.Free;
    end;
end;

function GetMatchs_V3(strText: string; strExp: string; Matchs: TStrings = nil; bMS: Boolean = false; bMG: Boolean = false; bMR: Boolean = false; iContent: integer = 0): integer;
begin
    result := GetMatchs(strText, strExp, Matchs, bMS, bMG, bMR, 3, 0);
end;

//StartPos: 从1开始
function FastPosNoCase(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;
var
    JumpTable: TBMJumpTable;
begin
    //If this assert failed, it is because you passed 0 for StartPos, lowest value is 1 !!
    Assert(StartPos > 0);
    if aFindLen < 1 then
    begin
        Result := 0;
        exit;
    end;
    if aFindLen > aSourceLen then
    begin
        Result := 0;
        exit;
    end;

    MakeBMTableNoCase(PChar(AFindString), aFindLen, JumpTable);
    Result := Integer(BMPosNoCase(PChar(aSourceString) + (StartPos - 1), PChar(aFindString), aSourceLen - (StartPos - 1), aFindLen, JumpTable));
    if Result > 0 then
        Result := Result - Integer(@aSourceString[1]) + 1;
end;

procedure MakeBMTableNoCase(Buffer: PChar; BufferLen: Integer; var JumpTable: TBMJumpTable);
begin
    if BufferLen = 0 then
        raise Exception.Create('BufferLen is 0');
    asm
        push    EDI
        push    ESI
        mov     EDI, JumpTable
        mov     EAX, BufferLen
        mov     ECX, $100
        REPNE   STOSD
        mov     EDX, GUpcaseLUT
        mov     ECX, BufferLen
        mov     EDI, JumpTable
        mov     ESI, Buffer
        dec     ECX
        XOR     EAX, EAX

@@loop:
        mov     AL, [ESI]
        lea     ESI, ESI + 1
        mov     AL, [EDX + EAX]
        mov     [EDI + EAX * 4], ECX
        dec     ECX
        jg      @@loop
        pop     ESI
        pop     EDI
    end;
end;

function BMPos(const aSource, aFind: Pointer; const aSourceLen, aFindLen: Integer; var JumpTable: TBMJumpTable): Pointer;
var
    LastPos: Pointer;
begin
    LastPos := Pointer(Integer(aSource) + aSourceLen - 1);
    asm
        push    ESI
        push    EDI
        push    EBX
        mov     EAX, aFindLen
        mov     ESI, aSource
        lea     ESI, ESI + EAX - 1
        std
        mov     EBX, JumpTable

@@comparetext:
        cmp     ESI, LastPos
        jg      @@NotFound
        mov     EAX, aFindLen
        mov     EDI, aFind
        mov     ECX, EAX
        push    ESI //Remember where we are
        lea     EDI, EDI + EAX - 1
        XOR     EAX, EAX

@@CompareNext:
        mov     al, [ESI]
        cmp     al, [EDI]
        jne     @@LookAhead
        lea     ESI, ESI - 1
        lea     EDI, EDI - 1
        dec     ECX
        jz      @@Found
        jmp     @@CompareNext

@@LookAhead:
    //Look up the char in our Jump Table
        pop     ESI
        mov     al, [ESI]
        mov     EAX, [EBX + EAX * 4]
        lea     ESI, ESI + EAX
        jmp     @@CompareText

@@NotFound:
        mov     Result, 0
        jmp     @@TheEnd

@@Found:
        pop     EDI //We are just popping, we don't need the value
        inc     ESI
        mov     Result, ESI

@@TheEnd:
        cld
        pop     EBX
        pop     EDI
        pop     ESI
    end;
end;

function BMPosNoCase(const aSource, aFind: Pointer; const aSourceLen, aFindLen: Integer; var JumpTable: TBMJumpTable): Pointer;
var
    LastPos: Pointer;
begin
    LastPos := Pointer(Integer(aSource) + aSourceLen - 1);
    asm
        push    ESI
        push    EDI
        push    EBX
        mov     EAX, aFindLen
        mov     ESI, aSource
        lea     ESI, ESI + EAX - 1
        std
        mov     EDX, GUpcaseLUT

@@comparetext:
        cmp     ESI, LastPos
        jg      @@NotFound
        mov     EAX, aFindLen
        mov     EDI, aFind
        push    ESI //Remember where we are
        mov     ECX, EAX
        lea     EDI, EDI + EAX - 1
        XOR     EAX, EAX

@@CompareNext:
        mov     al, [ESI]
        mov     bl, [EDX + EAX]
        mov     al, [EDI]
        cmp     bl, [EDX + EAX]
        jne     @@LookAhead
        lea     ESI, ESI - 1
        lea     EDI, EDI - 1
        dec     ECX
        jz      @@Found
        jmp     @@CompareNext

@@LookAhead:
    //Look up the char in our Jump Table
        pop     ESI
        mov     EBX, JumpTable
        mov     al, [ESI]
        mov     al, [EDX + EAX]
        mov     EAX, [EBX + EAX * 4]
        lea     ESI, ESI + EAX
        jmp     @@CompareText

@@NotFound:
        mov     Result, 0
        jmp     @@TheEnd

@@Found:
        pop     EDI //We are just popping, we don't need the value
        inc     ESI
        mov     Result, ESI

@@TheEnd:
        cld
        pop     EBX
        pop     EDI
        pop     ESI
    end;
end;

//字符串统计
function StrCount(Sub, S: string): Integer;
var
    ps, psub, tempps: PChar;
    step: Integer;
begin
    ps := PChar(S);
    psub := PChar(Sub);
    Result := 0;
    step := Length(Sub);
    while true do
    begin
        tempps := StrPos(ps, psub);
        if tempps = nil then
            Break
        else
        begin
            ps := tempps + step;
            Inc(Result);
        end;
    end;
end;

function FieldCount(const strRecord, strFs: string): integer;
begin
    result := StrCount(LowerCase(strFs), LowerCase(strRecord));
    if result < 1 then
        exit;
end;

//通过字段名称获取字段值
function GetFieldValueByName(RecordStr, FieldName: string; From: Integer = 1; Surround: string = '<>'): string;
var
    FieldValueStr, strFieldName: string;
    i, iNums: Integer;
    strFlag, ChLeft, ChRight: string;
    iBegin, iEnd: integer;
begin
    Result := '';
    FieldValueStr := RecordStr;
    iNums := FieldCount(FieldName, '.');
    for i := 0 to iNums do
    begin
        strFieldName := FieldValue('.', FieldName, i);
        if strFieldName = '' then
            continue;

        ChLeft := Surround[1];
        ChRight := Surround[2];

        strFlag := ChLeft + FieldName + ChRight;
        iBegin := FastPosNoCase(RecordStr, strFlag, Length(RecordStr), Length(strFlag), from);
        if (iBegin <= 0) then
            exit;
        iBegin := iBegin + Length(strFlag);

        strFlag := ChLeft + '/' + FieldName + ChRight;
        iEnd := FastPosNoCase(RecordStr, strFlag, Length(RecordStr), Length(strFlag), iBegin);
        if (iEnd <= 0) then
            exit;

        FieldValueStr := copy(RecordStr, iBegin, iEnd - iBegin);
    end;
    Result := FieldValueStr;
end;

function FieldValue(strSplit: string; str: string; iField: integer; cs: Boolean = False): string;
var
    i, ipos: integer;
    pString, pTmp: PChar;
    strFs, strRecord, strTmpRecord: string;
begin
    strFs := strSplit;
    strRecord := str;

    //优先处理iField=FIDX_LAST(2147483647)
    //目前代码效率不高, 日后优化...
    if iField = FIDX_LAST then
    begin
        //
        ipos := SmartPos(strFs, strRecord, false, length(strRecord), false);
        result := copy(strRecord, 1, ipos);

        //是否前一条
        ipos := SmartPos(strFs, result, false, length(result), false);
        if ipos > 0 then
            result := copy(result, ipos, length(result) - ipos);

        exit;
    end;

    try
        pString := @strRecord[1];
        for i := 0 to iField - 1 do
        begin
            if cs = False then
            begin
                ipos := NcPos(strFs, pString);
                if ipos > 0 then
                    pTmp := pchar(pString) + ipos - 1
                else
                    pTmp := nil;
            end
            else
            begin
                pTmp := AnsiStrPos(pchar(pString), pchar(strFs));
            end;

            if pTmp <> nil then
            begin
                pString := pTmp + length(strFs);
            end
            else
            begin
                pString := nil;
                break;
            end;
        end;

        strTmpRecord := string(pString);
        if cs = False then
            ipos := NcPos(strFs, strTmpRecord)
        else
            ipos := Pos(strFs, strTmpRecord);
        if ipos <> 0 then
            result := copy(strTmpRecord, 1, ipos - 1)
        else
            result := strTmpRecord;
    except
        result := '';
    end;
end;

//不区分大小写的pos
function NCPos(sub, source: string): integer;
begin
    Result := Pos(AnsiLowerCase(sub), AnsiLowerCase(source));
end;

function GetChineseWord(Text: string; len: Integer = 0): WideString;
var
    i, cnt: Integer;
    s: WideString;
begin
    Result := '';
    s := WideString(text);
    cnt := 0;
    if len = 0 then
        len := 999999999;
    for i := 1 to Length(s) do
    begin   //汉字的范围
        if ((s[i] >= #$4E00) and (s[i] <= #$9FA5)) or ((s[i] >= #$F900) and (s[i] <= #$FA2D)) then
        begin
            Result := Result + s[i];
            inc(cnt);
            if cnt >= len then
                Break;
        end;
    end;
end;

//判断是否是GBK 2500个常用字
function IsGBK(Text: string; DoNotJudgeLength: Boolean = False): Boolean;
const
    sWord = ',一,乙,二,十,丁,厂,七,卜,人,入,八,九,几,儿,了,力,乃,刀,又,三,于,干,亏,士,工,土,才,寸,下,大,丈,与,万,上,小,' + '口,巾,山,千,乞,川,亿,个,勺,久,凡,及,夕,丸,义,之,尸,弓,己,已,子,卫,也,女,飞,刃,习,叉,马,乡,丰,王,井,开,夫,' + '天,无,云,扎,艺,木,五,支,厅,不,太,犬,区,历,尤,友,匹,车,巨,牙,屯,比,互,切,日,中,冈,贝,内,水,见,午,牛,手,毛,' + '气,升,什,片,仆,化,仇,币,仍,仅,斤,爪,反,介,父,从,今,凶,仓,月,氏,勿,欠,风,丹,匀,乌,凤,勾,文,六,方,火,为,斗,' +
        '忆,订,认,心,尺,引,丑,巴,孔,队,办,以,双,书,幻,玉,刊,示,末,未,击,打,扑,扒,功,扔,去,甘,世,古,节,本,术,可,丙,' + '左,厉,右,石,布,龙,平,灭,轧,占,业,旧,帅,归,且,旦,目,叶,甲,申,叮,电,由,史,只,央,兄,叼,叫,另,叨,叹,四,生,失,' + '禾,丘,付,们,仪,白,仔,他,斥,瓜,乎,丛,令,用,甩,印,乐,句,匆,册,犯,外,鸟,务,包,饥,主,市,立,闪,兰,半,汉,宁,穴,' + '它,讨,写,让,礼,训,必,议,讯,记,永,司,尼,民,出,辽,奶,奴,加,召,皮,边,圣,对,台,矛,丝,式,刑,动,扛,寺,吉,扣,老,' +
        '执,巩,圾,扩,扫,地,扬,场,耳,共,芒,亚,芝,朽,朴,机,权,过,臣,再,协,在,有,百,存,而,页,匠,夸,夺,灰,达,列,死,轨,' + '邪,划,迈,毕,至,此,贞,师,尘,尖,劣,光,当,早,吐,团,同,吊,吃,因,吸,吗,屿,帆,岁,回,岂,刚,则,肉,网,年,朱,先,竹,' + '迁,乔,伟,传,乒,乓,休,伍,伏,件,任,伤,价,份,华,仰,仿,伙,伪,自,血,向,似,后,行,舟,全,会,杀,合,兆,企,众,爷,肌,' + '朵,杂,危,各,名,多,争,色,壮,冲,冰,庄,庆,亦,刘,齐,交,次,衣,产,决,充,妄,闭,问,闯,羊,并,关,米,灯,州,汗,忙,兴,' +
        '宇,守,宅,字,安,讲,军,许,论,农,讽,设,访,寻,那,迅,尽,导,异,孙,阵,阳,收,阶,阴,防,奸,如,妇,戏,羽,观,红,纤,级,' + '约,纪,驰,巡,寿,弄,麦,形,进,戒,吞,运,扶,抚,坛,技,坏,扰,拒,找,批,扯,址,走,抄,坝,贡,攻,赤,折,抓,扮,抢,投,坟,' + '抗,坑,坊,抖,护,壳,志,扭,块,声,把,劫,芽,花,芹,芬,苍,芳,严,芦,劳,克,苏,杆,杠,杜,材,李,杨,求,更,束,豆,两,丽,' + '医,辰,励,否,还,歼,来,连,步,坚,旱,时,吴,助,县,里,呆,园,旷,围,呀,男,困,吵,串,员,听,吩,吹,呜,吧,吼,别,岗,帐,' +
        '财,针,钉,告,我,乱,利,秃,秀,私,每,体,何,但,伸,佣,低,你,住,位,伴,身,皂,佛,近,彻,役,返,余,希,坐,谷,妥,含,邻,' + '岔,肝,肚,肠,龟,免,狂,犹,角,删,饭,饮,系,言,冻,状,亩,况,床,库,疗,应,冷,这,序,辛,弃,冶,忘,闲,间,闷,判,灶,灿,' + '弟,汪,沙,汽,沃,泛,沉,怀,忧,宋,宏,牢,究,穷,灾,良,证,启,评,补,初,社,识,诉,诊,词,译,君,灵,即,层,尿,尾,迟,局,' + '际,陆,阿,陈,阻,附,妙,妖,妨,劲,鸡,驱,纯,纱,纳,纲,驳,纵,纷,纸,纹,纺,驴,纽,奉,玩,环,武,青,责,现,抹,拢,拔,拣,' +
        '担,坦,押,抽,拐,拖,拍,者,顶,拆,拥,抵,拘,势,抱,垃,拉,拦,坡,披,拨,择,抬,其,取,苦,若,茂,苹,苗,英,茄,茎,茅,林,' + '枝,杯,柜,析,板,松,枪,构,杰,述,枕,丧,事,刺,枣,雨,卖,矿,码,厕,奔,奇,奋,态,欧,垄,妻,轰,顷,转,斩,到,非,叔,肯,' + '齿,些,虎,虏,肾,贤,果,味,昆,国,昌,畅,明,易,昂,典,固,忠,咐,呼,鸣,咏,呢,岸,岩,帖,罗,帜,岭,凯,败,图,钓,制,知,' + '乖,刮,秆,和,季,委,佳,侍,供,使,例,版,侄,侦,侧,凭,侨,佩,货,依,的,迫,质,欣,征,往,爬,彼,径,所,爸,采,受,乳,贪,' +
        '念,贫,肤,肺,肢,肿,胀,朋,股,肥,服,胁,周,昏,鱼,兔,狐,忽,狗,备,饰,饱,饲,变,京,享,府,底,剂,净,盲,放,刻,育,闸,' + '闹,郑,券,卷,单,炒,炊,炕,炎,炉,沫,浅,法,泄,河,沾,泪,油,泊,沿,泳,泥,沸,波,泼,泽,治,怖,性,怪,学,宝,宗,定,宜,' + '审,宙,官,空,帘,实,试,郎,诗,肩,房,诚,衬,衫,询,该,详,建,肃,录,隶,居,届,刷,屈,弦,承,孟,孤,限,妹,姑,姐,姓,始,' + '驾,参,艰,线,练,组,细,驶,驼,绍,经,贯,奏,春,帮,珍,玻,毒,型,持,项,垮,挎,城,挠,政,赴,赵,挡,挺,括,拴,拾,挑,指,' +
        '垫,挣,挤,拼,挖,按,甚,革,荐,巷,带,草,茧,茶,荒,茫,荡,荣,故,药,标,枯,柄,栋,相,查,柏,柳,柱,柿,栏,树,要,咸,威,' + '厘,厚,砌,砍,面,耐,耍,牵,残,殃,轻,鸦,皆,背,战,点,临,览,竖,尝,是,盼,眨,哄,显,哑,冒,映,星,胃,贵,界,虹,虾,蚁,' + '思,蚂,虽,品,咽,骂,哗,咱,响,哈,咬,咳,哪,炭,峡,罚,贱,贴,骨,钢,钥,钩,卸,矩,怎,牲,选,适,秒,香,种,秋,科,重,复,' + '竿,段,便,俩,贷,顺,修,保,促,侮,俭,俗,俘,信,皇,泉,鬼,侵,律,很,须,叙,剑,逃,食,盆,胆,胜,胞,胖,脉,勉,狭,狮,独,' +
        '狡,狱,狠,贸,怨,急,饶,蚀,饺,饼,弯,将,奖,哀,迹,庭,疮,疤,姿,亲,音,帝,施,闻,阀,阁,差,养,美,姜,叛,送,类,迷,前,' + '首,逆,总,炼,炸,炮,烂,剃,浇,浊,洞,测,洗,活,派,洽,染,洲,浑,浓,津,恒,恢,恰,恼,恨,举,觉,宣,室,宫,宪,突,穿,窃,' + '客,冠,祖,神,祝,误,诱,说,诵,垦,退,既,屋,昼,费,陡,眉,险,院,娃,姥,姨,姻,娇,怒,架,贺,盈,勇,怠,柔,结,绕,骄,绘,' + '给,络,骆,绝,绞,统,耕,耗,艳,泰,珠,班,素,盏,匪,捞,栽,捕,振,载,赶,起,盐,捎,捏,埋,捉,捆,捐,损,都,哲,逝,捡,换,' +
        '壶,挨,耻,耽,恭,莲,莫,荷,获,晋,恶,真,框,桐,株,桥,桃,格,校,核,样,根,索,哥,速,逗,栗,配,翅,础,破,原,套,逐,烈,' + '殊,顾,轿,较,顿,毙,致,柴,桌,虑,监,紧,党,晓,鸭,晃,晌,晕,蚊,哨,哭,恩,唤,峰,圆,贼,贿,钱,钳,钻,铁,铃,铅,缺,氧,' + '特,牺,造,乘,敌,秤,租,积,秧,秩,称,秘,透,笋,债,借,值,倘,俱,倡,候,俯,倍,倦,健,臭,射,躬,息,徒,徐,舰,舱,般,航,' + '途,拿,爹,爱,颂,翁,脆,脂,胸,胳,脏,胶,留,皱,饿,恋,桨,浆,衰,高,席,准,座,脊,症,病,疾,疼,疲,效,离,唐,资,凉,站,' +
        '剖,竞,部,旁,旅,畜,阅,羞,料,益,兼,烦,烧,烛,烟,递,涛,浙,涝,酒,涉,消,浩,海,涂,浴,浮,流,润,浪,浸,涨,烫,涌,悟,' + '悄,悔,家,宵,宴,宾,窄,容,宰,案,请,读,扇,袜,袖,袍,被,祥,课,谁,调,冤,谅,谈,谊,剥,恳,展,剧,屑,弱,陪,娱,娘,通,' + '能,难,预,桑,绢,绣,验,继,球,理,捧,堵,描,域,掩,掉,堆,推,掀,授,教,掏,掠,培,接,控,探,据,掘,职,基,著,勒,黄,萌,' + '萝,菌,萍,菠,营,械,梦,梢,梅,检,梳,梯,桶,救,副,爽,聋,袭,盛,雪,辅,辆,虚,雀,堂,常,匙,晨,睁,眯,眼,晚,啄,距,跃,' +
        '略,蛇,累,唱,患,唯,崖,崭,崇,圈,铜,铲,银,甜,梨,笨,笼,笛,符,第,敏,做,袋,悠,偿,售,停,偏,假,得,衔,盘,船,斜,盒,' + '鸽,悉,欲,彩,领,脚,脖,脸,脱,象,够,猜,猪,猎,猫,馆,凑,减,毫,廊,康,庸,鹿,盗,章,竟,商,族,旋,望,率,着,盖,粘,粗,' + '粒,断,剪,兽,清,添,淋,淹,渠,渐,混,渔,淘,液,渗,情,惜,惭,悼,惧,惕,惊,惨,惯,寇,寄,宿,窑,密,谋,谎,祸,谜,逮,敢,' + '屠,弹,随,蛋,隆,隐,婚,婶,颈,绩,绳,维,绵,琴,斑,替,款,堪,搭,塔,趋,超,提,堤,博,揭,喜,插,揪,搜,煮,援,裁,搁,搂,' +
        '搅,握,揉,斯,期,欺,联,葛,董,葡,敬,葱,落,朝,辜,葵,棒,棋,植,森,棵,棍,棉,棚,棕,惠,惑,逼,厨,厦,硬,确,雁,殖,裂,' + '雄,悲,紫,辉,敞,赏,掌,晴,暑,最,量,喷,晶,喇,遇,喊,景,践,跌,跑,蛛,蜓,喝,喂,喘,喉,幅,帽,赌,赔,链,销,锁,锄,锅,' + '锈,锋,锐,短,智,毯,鹅,剩,稍,程,稀,税,筐,等,筑,策,筛,筒,答,筋,傅,牌,堡,集,奥,街,惩,御,循,艇,舒,番,释,禽,腊,' + '脾,腔,鲁,猾,猴,然,馋,装,蛮,就,痛,童,阔,善,羡,普,粪,尊,道,渣,湿,温,渴,滑,湾,渡,游,滋,溉,愤,慌,惰,愧,愉,慨,' +
        '割,寒,富,窜,窝,窗,遍,裕,裤,裙,谢,谣,谦,属,屡,隔,隙,絮,缎,缓,编,骗,缘,瑞,魂,肆,摄,摸,填,搏,摆,携,搬,摇,搞,' + '塘,摊,蒜,勤,鹊,蓝,墓,幕,蓬,蓄,蒙,蒸,献,禁,楚,想,槐,赖,酬,感,碍,碑,碎,碰,碗,碌,雷,零,雾,雹,龄,鉴,睛,睡,睬,' + '鄙,愚,暖,盟,歇,暗,照,跨,跳,跪,路,蜂,嗓,置,罪,罩,错,锡,锣,锤,锦,键,锯,矮,辞,稠,愁,筹,签,简,鼠,催,傻,像,躲,' + '微,愈,遥,腰,腥,触,解,酱,痰,廉,新,韵,意,粮,数,煎,塑,慈,煤,煌,满,漠,源,滤,滥,滔,溪,溜,滚,滨,慎,誉,塞,谨,辟,' +
        '障,嫌,嫁,叠,缝,缠,静,碧,璃,墙,撇,嘉,摧,境,摘,摔,聚,蔽,慕,暮,蔑,模,榴,榜,榨,歌,遭,酷,酿,酸,磁,愿,需,弊,裳,' + '蜡,蝇,蜘,赚,锹,锻,舞,稳,算,箩,管,僚,鼻,膜,膊,膀,鲜,疑,馒,裹,敲,豪,膏,遮,腐,瘦,辣,竭,端,熄,熔,漆,漂,漫,滴,' + '演,漏,慢,寨,赛,察,蜜,谱,嫩,翠,熊,凳,骡,缩,慧,撕,撒,趣,趟,撑,播,增,聪,鞋,蕉,蔬,横,槽,樱,橡,飘,醋,醉,震,霉,' + '瞒,题,暴,瞎,影,踢,踏,踩,嘱,墨,镇,靠,稻,黎,稿,稼,箱,箭,篇,僵,躺,艘,膝,膛,熟,摩,颜,毅,糊,遵,潜,潮,懂,额,慰,' +
        '劈,操,燕,薯,薪,薄,颠,橘,醒,餐,嘴,蹄,器,赠,默,镜,赞,篮,邀,衡,膨,雕,磨,凝,辨,辩,糖,糕,燃,澡,避,缴,戴,擦,鞠,' + '藏,霜,霞,瞧,穗,繁,辫,赢,糟,糠,燥,臂,翼,骤,鞭,覆,蹦,镰,翻,鹰,警,攀,蹲,颤,瓣,爆,疆,壤,耀,躁,嚼,嚷,籍,魔,灌,' + '蠢,霸,露,囊,罐,专,元,仁,长,户,计,正,巧,田,号,冬,处,孕,发,托,考,夹,成,舌,丢,创,伞,买,欢,违,远,却,报,呈,盯,' + '估,兵,完,快,忍,努,规,表,直,范,软,轮,购,贩,废,郊,怜,怕,降,陕,封,挂,南,胡,削,省,钟,钞,疫,疯,洋,济,除,孩,顽,' +
        '蚕,档,桂,眠,晒,笑,笔,烘,烤,诸,朗,排,捷,戚,票,移,犁,馅,猛,绿,绸,趁,越,椒,椅,蛙,遗,傲,筝,登,嫂,鼓,塌,督,输,' + '舅,毁,滩,粱,誓,截,貌,魄,撤,撞,德,僻,融,整,螺,蹈,少,止,瓦,公,乏,分,劝,予,允,北,卡,东,仙,代,仗,头,汇,汁,幼,' + '母,纠,厌,压,西,曲,虫,吓,延,伐,优,负,旨,旬,妈,她,好,抛,均,孝,极,杏,村,邮,足,吨,伶,伯,作,沈,没,沟,忌,张,改,' + '招,幸,拌,卧,画,或,具,旺,尚,物,牧,垂,庙,夜,店,泻,注,泡,诞,话,视,驻,终,织,某,挪,挥,砖,研,歪,趴,畏,昨,看,拜,' +
        '缸,度,亮,亭,洒,洪,洁,袄,扁,语,绒,绑,垒,恐,热,挽,夏,唇,辱,罢,唉,啊,倒,倾,倚,粉,拳,瓶,宽,害,悦,陷,陶,陵,菊,' + '萄,菜,啦,野,悬,您,偷,偶,痕,痒,麻,骑,续,绪,葬,惹,散,辈,雅,暂,铺,铸,黑,储,傍,焦,疏,粥,强,概,楼,榆,蛾,遣,跟,' + '腿,腾,腹,殿,群,福,蜻,嗽,颗,歉,精,旗,蝴,蝶,踪,壁,懒,激,门,亡,广,么,汤,池,江,污,迎,岛,卵,条,斧,命,金,舍,待,' + '盾,俊,追,逢,狼,狸,脑,梁,婆,深,淡,湖,港,焰,曾,';
var
    i: Integer;
    cnt, maxcnt: Integer;
    s: WideString;
begin
    Result := True;
    s := GetChineseWord(Text, 50);
    if not DoNotJudgeLength then
    begin
        if Length(s) < 10 then
            Exit;
    end;

    cnt := 0;
    maxcnt := Length(s);
    for i := 1 to maxcnt do
    begin
        if Pos(s[i], sWord) > 0 then
        begin
            inc(cnt);
        end;
    end;

    if cnt / maxcnt < 0.6 then
        Result := False
    else
        Result := True;
end;

function Utf8ToGb2312(const unicodestr: string): string;
var
    SourceLength: Integer;
    DoneLength: Integer;
    AscNo: Integer;
    Byte1, Byte2, Byte3: Integer;
    GbStr: string;
begin
    GbStr := '';
    Byte1 := 0;
    Byte2 := 0;
    Byte3 := 0;

    if Trim(unicodestr) = '' then
        Exit;

    SourceLength := Length(UnicodeStr);
    DoneLength := 1;
    repeat
        AscNo := Ord(UnicodeStr[DoneLength]);
        case (AscNo and $E0) of
            $E0:
                begin
                    Byte1 := (AscNo and $0f) shl 12;
                    Inc(DoneLength);
                    if DoneLength > SourceLength then
                        Break;
                    AscNo := Ord(UnicodeStr[DoneLength]);
                    Byte2 := (AscNo and $3f) shl 6;
                    Inc(DoneLength);
                    if DoneLength > SourceLength then
                        Break;
                    AscNo := Ord(UnicodeStr[DoneLength]);
                    Byte3 := AscNo and $3f;
                end;
            $C0:
                begin
                    Byte1 := (AscNo and $1f) shl 6;
                    Inc(DoneLength);
                    if DoneLength > SourceLength then
                        Break;
                    AscNo := Ord(UnicodeStr[DoneLength]);
                    Byte2 := (AscNo and $3f);
                    Byte3 := 0;
                end;
            0..$bf:
                begin
                    Byte1 := AscNo;
                    Byte2 := 0;
                    Byte3 := 0;
                end;
        end; //case;
        GbStr := GBStr + Widechar(Byte1 + Byte2 + Byte3);
        Inc(DoneLength);
        if DoneLength > SourceLength then
            Break;
    until DoneLength >= SourceLength;

    Result := GbStr;
end;

function HtmlToGbk(html: string): string;
var
    i: Integer;
begin
    i := Pos('<!DOCTYPE html', html);
    if i > 0 then
        html := Copy(html, i, Length(html) + 100);

    if not IsGBK(html) then
    begin
        Result := Utf8ToAnsi(html);
        if Trim(Result) = '' then
            Result := Utf8ToGb2312(html);
        if Trim(Result) = '' then
            Result := html;
    end
    else
    begin
        Result := html;
    end;
end;

function SmartPos(const SearchStr, SourceStr: string; const CaseSensitive: Boolean = TRUE; const StartPos: Integer = 1; const ForwardSearch: Boolean = TRUE): Integer;
begin
  // NOTE:  When using StartPos, the returned value is absolute!
    if (CaseSensitive) then
        if (ForwardSearch) then
            Result := FastPos(SourceStr, SearchStr, Length(SourceStr), Length(SearchStr), StartPos)
        else
            Result := FastPosBack(SourceStr, SearchStr, Length(SourceStr), Length(SearchStr), StartPos)
    else if (ForwardSearch) then
        Result := FastPosNoCase(SourceStr, SearchStr, Length(SourceStr), Length(SearchStr), StartPos)
    else
        Result := FastPosBackNoCase(SourceStr, SearchStr, Length(SourceStr), Length(SearchStr), StartPos)
end;

function FastPos(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;
var
    JumpTable: TBMJumpTable;
begin
  //If this assert failed, it is because you passed 0 for StartPos, lowest value is 1 !!
    Assert(StartPos > 0);
    if aFindLen < 1 then
    begin
        Result := 0;
        exit;
    end;
    if aFindLen > aSourceLen then
    begin
        Result := 0;
        exit;
    end;

    MakeBMTable(PChar(aFindString), aFindLen, JumpTable);
    Result := Integer(BMPos(PChar(aSourceString) + (StartPos - 1), PChar(aFindString), aSourceLen - (StartPos - 1), aFindLen, JumpTable));
    if Result > 0 then
        Result := Result - Integer(@aSourceString[1]) + 1;
end;

function FastPosBack(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;
var
    SourceLen: Integer;
begin
    if aFindLen < 1 then
    begin
        Result := 0;
        exit;
    end;
    if aFindLen > aSourceLen then
    begin
        Result := 0;
        exit;
    end;

    if (StartPos = 0) or (StartPos + aFindLen > aSourceLen) then
        SourceLen := aSourceLen - (aFindLen - 1)
    else
        SourceLen := StartPos;

    asm
        push    ESI
        push    EDI
        push    EBX
        mov     EDI, aSourceString
        add     EDI, SourceLen
        Dec     EDI
        mov     ESI, aFindString
        mov     ECX, SourceLen
        Mov     Al, [ESI]

@ScaSB:
        cmp     Al, [EDI]
        jne     @NextChar

@CompareStrings:
        mov     EBX, aFindLen
        dec     EBX
        jz      @FullMatch

@CompareNext:
        mov     Ah, [ESI + EBX]
        cmp     Ah, [EDI + EBX]
        Jnz     @NextChar

@Matches:
        Dec     EBX
        Jnz     @CompareNext

@FullMatch:
        mov     EAX, EDI
        sub     EAX, aSourceString
        inc     EAX
        mov     Result, EAX
        jmp     @TheEnd

@NextChar:
        dec     EDI
        dec     ECX
        jnz     @ScaSB
        mov     Result, 0

@TheEnd:
        pop     EBX
        pop     EDI
        pop     ESI
    end;
end;

function FastPosBackNoCase(const aSourceString, aFindString: string; const aSourceLen, aFindLen, StartPos: Integer): Integer;
var
    SourceLen: Integer;
begin
    if aFindLen < 1 then
    begin
        Result := 0;
        exit;
    end;
    if aFindLen > aSourceLen then
    begin
        Result := 0;
        exit;
    end;

    if (StartPos = 0) or (StartPos + aFindLen > aSourceLen) then
        SourceLen := aSourceLen - (aFindLen - 1)
    else
        SourceLen := StartPos;

    asm
        push    ESI
        push    EDI
        push    EBX
        mov     EDI, aSourceString
        add     EDI, SourceLen
        Dec     EDI
        mov     ESI, aFindString
        mov     ECX, SourceLen
        mov     EDX, GUpcaseLUT
        XOR     EBX, EBX
        mov     Bl, [ESI]
        mov     Al, [EDX + EBX]

@ScaSB:
        mov     Bl, [EDI]
        cmp     Al, [EDX + EBX]
        jne     @NextChar

@CompareStrings:
        PUSH    ECX
        mov     ECX, aFindLen
        dec     ECX
        jz      @FullMatch

@CompareNext:
        mov     Bl, [ESI + ECX]
        mov     Ah, [EDX + EBX]
        mov     Bl, [EDI + ECX]
        cmp     Ah, [EDX + EBX]
        Jz      @Matches
//Go back to findind the first char
        POP     ECX
        Jmp     @NextChar

@Matches:
        Dec     ECX
        Jnz     @CompareNext

@FullMatch:
        POP     ECX
        mov     EAX, EDI
        sub     EAX, aSourceString
        inc     EAX
        mov     Result, EAX
        jmp     @TheEnd

@NextChar:
        dec     EDI
        dec     ECX
        jnz     @ScaSB
        mov     Result, 0

@TheEnd:
        pop     EBX
        pop     EDI
        pop     ESI
    end;
end;

procedure MakeBMTable(Buffer: PChar; BufferLen: Integer; var JumpTable: TBMJumpTable);
begin
    if BufferLen = 0 then
        raise Exception.Create('BufferLen is 0');
    asm
        push    EDI
        push    ESI
        mov     EDI, JumpTable
        mov     EAX, BufferLen
        mov     ECX, $100
        REPNE   STOSD
        mov     ECX, BufferLen
        mov     EDI, JumpTable
        mov     ESI, Buffer
        dec     ECX
        XOR     EAX, EAX

@@loop:
        mov     AL, [ESI]
        lea     ESI, ESI + 1
        mov     [EDI + EAX * 4], ECX
        dec     ECX
        jg      @@loop
        pop     ESI
        pop     EDI
    end;
end;

initialization
    //...
	{$IFNDEF LINUX}
    for I := 0 to 255 do
        GUpcaseTable[I] := Chr(I);
    CharUpperBuff(@GUpcaseTable[0], 256);
	{$ELSE}
    for I := 0 to 255 do
        GUpcaseTable[I] := UpCase(Chr(I));
	{$ENDIF}
    GUpcaseLUT := @GUpcaseTable[0];

finalization


end.


